{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport * as THREE from 'three';\nimport { Vector2, Raycaster, Scene, OrthographicCamera, PerspectiveCamera, WebGLRenderer, PCFSoftShadowMap, Vector3, Math as Math$1 } from 'three';\nimport { createContext, memo, useState, useRef, useLayoutEffect, useCallback, useEffect, createElement, useContext, useMemo } from 'react';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport Reconciler from 'react-reconciler';\nimport { unstable_now, unstable_scheduleCallback, unstable_cancelCallback, unstable_runWithPriority, unstable_IdlePriority } from 'scheduler';\nvar version = \"2.4.3\";\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nconst roots = new Map();\nconst emptyObject = {};\nconst is = {\n  obj: a => a === Object(a),\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  und: a => a === void 0,\n  arr: a => Array.isArray(a),\n\n  equ(a, b) {\n    // Wrong type, doesn't match\n    if (typeof a !== typeof b) return false; // Atomic, just compare a against b\n\n    if (is.str(a) || is.num(a) || is.obj(a)) return a === b; // Array, shallow compare first to see if it's a match\n\n    if (is.arr(a) && a == b) return true; // Last resort, go through keys\n\n    let i;\n\n    for (i in a) if (!(i in b)) return false;\n\n    for (i in b) if (a[i] !== b[i]) return false;\n\n    return is.und(i) ? a === b : true;\n  }\n\n};\nlet globalEffects = [];\n\nfunction addEffect(callback) {\n  globalEffects.push(callback);\n}\n\nfunction renderGl(state, timestamp, repeat, runGlobalEffects) {\n  if (repeat === void 0) {\n    repeat = 0;\n  }\n\n  if (runGlobalEffects === void 0) {\n    runGlobalEffects = false;\n  } // Run global effects\n\n\n  if (runGlobalEffects) globalEffects.forEach(effect => effect(timestamp) && repeat++); // Run local effects\n\n  state.current.subscribers.forEach(fn => fn(state.current, timestamp)); // Decrease frame count\n\n  state.current.frames = Math.max(0, state.current.frames - 1);\n  repeat += !state.current.invalidateFrameloop ? 1 : state.current.frames; // Render content\n\n  if (!state.current.manual && state.current.gl) state.current.gl.render(state.current.scene, state.current.camera);\n  return repeat;\n}\n\nlet running = false;\n\nfunction renderLoop(timestamp) {\n  running = true;\n  let repeat = 0; // Run global effects\n\n  globalEffects.forEach(effect => effect(timestamp) && repeat++);\n  roots.forEach(root => {\n    const state = root.containerInfo.__state; // If the frameloop is invalidated, do not run another frame\n\n    if (state.current.active && state.current.ready && (!state.current.invalidateFrameloop || state.current.frames > 0)) repeat = renderGl(state, timestamp, repeat);\n  });\n  if (repeat !== 0) return requestAnimationFrame(renderLoop); // Flag end of operation\n\n  running = false;\n}\n\nfunction invalidate(state, frames) {\n  if (state === void 0) {\n    state = true;\n  }\n\n  if (frames === void 0) {\n    frames = 2;\n  }\n\n  if (state === true) roots.forEach(root => root.containerInfo.__state.current.frames = frames);else if (state && state.current) {\n    if (state.current.vr) return;\n    state.current.frames = frames;\n  }\n\n  if (!running) {\n    running = true;\n    requestAnimationFrame(renderLoop);\n  }\n}\n\nlet catalogue = {};\n\nconst extend = objects => void (catalogue = _extends({}, catalogue, objects));\n\nfunction applyProps(instance, newProps, oldProps, accumulative) {\n  if (oldProps === void 0) {\n    oldProps = {};\n  }\n\n  if (accumulative === void 0) {\n    accumulative = false;\n  } // Filter equals, events and reserved props\n\n\n  const container = instance.__container;\n  const sameProps = Object.keys(newProps).filter(key => is.equ(newProps[key], oldProps[key]));\n  const handlers = Object.keys(newProps).filter(key => typeof newProps[key] === 'function' && key.startsWith('on'));\n  const leftOvers = accumulative ? Object.keys(oldProps).filter(key => newProps[key] === void 0) : [];\n  const filteredProps = [...sameProps, 'children', 'key', 'ref'].reduce((acc, prop) => {\n    let _ = acc[prop],\n        rest = _objectWithoutPropertiesLoose(acc, [prop].map(_toPropertyKey));\n\n    return rest;\n  }, newProps); // Add left-overs as undefined props so they can be removed\n\n  leftOvers.forEach(key => filteredProps[key] = undefined);\n\n  if (Object.keys(filteredProps).length > 0) {\n    Object.entries(filteredProps).forEach(_ref => {\n      let key = _ref[0],\n          value = _ref[1];\n\n      if (!handlers.includes(key)) {\n        let root = instance;\n        let target = root[key];\n\n        if (key.includes('-')) {\n          const entries = key.split('-');\n          target = entries.reduce((acc, key) => acc[key], instance); // If the target is atomic, it forces us to switch the root\n\n          if (!(target && target.set)) {\n            const _entries$reverse = entries.reverse(),\n                  name = _entries$reverse[0],\n                  reverseEntries = _entries$reverse.slice(1);\n\n            root = reverseEntries.reverse().reduce((acc, key) => acc[key], instance);\n            key = name;\n          }\n        } // Special treatment for objects with support for set/copy\n\n\n        if (target && target.set && target.copy) {\n          if (target.constructor.name === value.constructor.name) target.copy(value);else if (Array.isArray(value)) target.set(...value);else target.set(value); // Else, just overwrite the value\n        } else root[key] = value;\n\n        invalidateInstance(instance);\n      }\n    }); // Preemptively delete the instance from the containers interaction\n\n    if (accumulative && container && instance.raycast && instance.__handlers) {\n      instance.__handlers = undefined;\n\n      const index = container.__interaction.indexOf(instance);\n\n      if (index > -1) container.__interaction.splice(index, 1);\n    } // Prep interaction handlers\n\n\n    if (handlers.length) {\n      // Add interactive object to central container\n      if (container && instance.raycast) {\n        // Unless the only onUpdate is the only event present we flag the instance as interactive\n        if (!(handlers.length === 1 && handlers[0] === 'onUpdate')) container.__interaction.push(instance);\n      } // Add handlers to the instances handler-map\n\n\n      instance.__handlers = handlers.reduce((acc, key) => _extends({}, acc, {\n        [key.charAt(2).toLowerCase() + key.substr(3)]: newProps[key]\n      }), {});\n    } // Call the update lifecycle when it is being updated, but only when it is part of the scene\n\n\n    if (instance.parent) updateInstance(instance);\n  }\n}\n\nfunction invalidateInstance(instance) {\n  if (instance.__container && instance.__container.__state) invalidate(instance.__container.__state);\n}\n\nfunction updateInstance(instance) {\n  if (instance.__handlers && instance.__handlers.update) instance.__handlers.update(instance);\n}\n\nfunction createInstance(type, _ref2, container) {\n  let _ref2$args = _ref2.args,\n      args = _ref2$args === void 0 ? [] : _ref2$args,\n      props = _objectWithoutPropertiesLoose(_ref2, [\"args\"]);\n\n  let name = \"\" + type[0].toUpperCase() + type.slice(1);\n  let instance;\n\n  if (type === 'primitive') {\n    instance = props.object;\n    instance.__instance = true;\n  } else {\n    const target = catalogue[name] || THREE[name];\n    instance = is.arr(args) ? new target(...args) : new target(args);\n  } // Bind to the root container in case portals are being used\n  // This is perhaps better for event management as we can keep them on a single instance\n\n\n  while (container.__container) {\n    container = container.__container;\n  } // Apply initial props\n\n\n  instance.__objects = [];\n  instance.__container = container; // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n  // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n  // why it passes \"false\" here\n\n  applyProps(instance, props, {});\n  return instance;\n}\n\nfunction appendChild(parentInstance, child) {\n  if (child) {\n    if (child.isObject3D) parentInstance.add(child);else {\n      parentInstance.__objects.push(child);\n\n      child.parent = parentInstance; // The attach attribute implies that the object attaches itself on the parent\n\n      if (child.attach) parentInstance[child.attach] = child;else if (child.attachArray) {\n        if (!is.arr(parentInstance[child.attachArray])) parentInstance[child.attachArray] = [];\n        parentInstance[child.attachArray].push(child);\n      } else if (child.attachObject) {\n        if (!is.obj(parentInstance[child.attachObject[0]])) parentInstance[child.attachObject[0]] = {};\n        parentInstance[child.attachObject[0]][child.attachObject[1]] = child;\n      }\n    }\n    updateInstance(child);\n    invalidateInstance(child);\n  }\n}\n\nfunction insertBefore(parentInstance, child, beforeChild) {\n  if (child) {\n    if (child.isObject3D) {\n      child.parent = parentInstance;\n      child.dispatchEvent({\n        type: 'added'\n      }); // TODO: the order is out of whack if data objects are present, has to be recalculated\n\n      const index = parentInstance.children.indexOf(beforeChild);\n      parentInstance.children = [...parentInstance.children.slice(0, index), child, ...parentInstance.children.slice(index)];\n      updateInstance(child);\n    } else appendChild(parentInstance, child); // TODO: order!!!\n\n\n    invalidateInstance(child);\n  }\n}\n\nfunction removeRecursive(array, parent, clone) {\n  if (clone === void 0) {\n    clone = false;\n  }\n\n  if (array) {\n    // Three uses splice op's internally we may have to shallow-clone the array in order to safely remove items\n    const target = clone ? [...array] : array;\n    target.forEach(child => removeChild(parent, child));\n  }\n}\n\nfunction removeChild(parentInstance, child) {\n  if (child) {\n    if (child.isObject3D) {\n      parentInstance.remove(child);\n    } else {\n      child.parent = null;\n      parentInstance.__objects = parentInstance.__objects.filter(x => x !== child); // Remove attachment\n\n      if (child.attach) parentInstance[child.attach] = null;else if (child.attachArray) parentInstance[child.attachArray] = parentInstance[child.attachArray].filter(x => x !== child);else if (child.attachObject) {\n        delete parentInstance[child.attachObject[0]][child.attachObject[1]];\n      }\n    }\n\n    invalidateInstance(child);\n    unstable_runWithPriority(unstable_IdlePriority, () => {\n      // Remove interactivity\n      if (child.__container) child.__container.__interaction = child.__container.__interaction.filter(x => x !== child); // Remove nested child objects\n\n      removeRecursive(child.__objects, child);\n      removeRecursive(child.children, child, true); // Dispose item\n\n      if (child.dispose) child.dispose(); // Remove references\n\n      delete child.__container;\n      delete child.__objects;\n    });\n  }\n}\n\nfunction switchInstance(instance, type, newProps, fiber) {\n  const parent = instance.parent;\n  const newInstance = createInstance(type, newProps, instance.__container);\n  removeChild(parent, instance);\n  appendChild(parent, newInstance) // This evil hack switches the react-internal fiber node\n  // https://github.com/facebook/react/issues/14983\n  // https://github.com/facebook/react/pull/15021\n  ;\n  [fiber, fiber.alternate].forEach(fiber => {\n    if (fiber !== null) {\n      fiber.stateNode = newInstance;\n\n      if (fiber.ref) {\n        if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;\n      }\n    }\n  });\n}\n\nconst Renderer = Reconciler({\n  now: unstable_now,\n  createInstance,\n  removeChild,\n  appendChild,\n  insertBefore,\n  supportsMutation: true,\n  isPrimaryRenderer: false,\n  // @ts-ignore\n  schedulePassiveEffects: unstable_scheduleCallback,\n  cancelPassiveEffects: unstable_cancelCallback,\n  appendInitialChild: appendChild,\n  appendChildToContainer: appendChild,\n  removeChildFromContainer: removeChild,\n  insertInContainerBefore: insertBefore,\n\n  commitUpdate(instance, updatePayload, type, oldProps, newProps, fiber) {\n    if (instance.__instance && newProps.object && newProps.object !== instance) {\n      // <instance object={...} /> where the object reference has changed\n      switchInstance(instance, type, newProps, fiber);\n    } else if (instance.isObject3D) {\n      // Common Threejs scene object\n      applyProps(instance, newProps, oldProps, true);\n    } else {\n      // This is a data object, let's extract critical information about it\n      const _newProps$args = newProps.args,\n            argsNew = _newProps$args === void 0 ? [] : _newProps$args,\n            restNew = _objectWithoutPropertiesLoose(newProps, [\"args\"]);\n\n      const _oldProps$args = oldProps.args,\n            argsOld = _oldProps$args === void 0 ? [] : _oldProps$args,\n            restOld = _objectWithoutPropertiesLoose(oldProps, [\"args\"]); // If it has new props or arguments, then it needs to be re-instanciated\n\n\n      const hasNewArgs = argsNew.some((value, index) => is.obj(value) ? Object.entries(value).some(_ref3 => {\n        let key = _ref3[0],\n            val = _ref3[1];\n        return val !== argsOld[index][key];\n      }) : value !== argsOld[index]);\n\n      if (hasNewArgs) {\n        // Next we create a new instance and append it again\n        switchInstance(instance, type, newProps, fiber);\n      } else {\n        // Otherwise just overwrite props\n        applyProps(instance, restNew, restOld, true);\n      }\n    }\n  },\n\n  hideInstance(instance) {\n    if (instance.isObject3D) {\n      instance.visible = false;\n      invalidateInstance(instance);\n    }\n  },\n\n  unhideInstance(instance, props) {\n    if (instance.isObject3D && props.visible == null || props.visible) {\n      instance.visible = true;\n      invalidateInstance(instance);\n    }\n  },\n\n  getPublicInstance(instance) {\n    return instance;\n  },\n\n  getRootHostContext() {\n    return emptyObject;\n  },\n\n  getChildHostContext() {\n    return emptyObject;\n  },\n\n  createTextInstance() {},\n\n  finalizeInitialChildren() {\n    return false;\n  },\n\n  prepareUpdate() {\n    return emptyObject;\n  },\n\n  shouldDeprioritizeSubtree() {\n    return false;\n  },\n\n  prepareForCommit() {},\n\n  resetAfterCommit() {},\n\n  shouldSetTextContent() {\n    return false;\n  }\n\n});\n\nfunction render(element, container, state) {\n  let root = roots.get(container);\n\n  if (!root) {\n    container.__state = state;\n    let newRoot = root = Renderer.createContainer(container, false, false);\n    roots.set(container, newRoot);\n  }\n\n  Renderer.updateContainer(element, root, null, () => undefined);\n  return Renderer.getPublicRootInstance(root);\n}\n\nfunction unmountComponentAtNode(container) {\n  const root = roots.get(container);\n  if (root) Renderer.updateContainer(null, root, null, () => void roots.delete(container));\n}\n\nconst hasSymbol = typeof Symbol === 'function' && Symbol.for;\nconst REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\n\nfunction createPortal(children, containerInfo, implementation, key) {\n  if (key === void 0) {\n    key = null;\n  }\n\n  return {\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children,\n    containerInfo,\n    implementation\n  };\n}\n\nRenderer.injectIntoDevTools({\n  bundleType: process.env.NODE_ENV === 'production' ? 0 : 1,\n  version: version,\n  rendererPackageName: 'react-three-fiber',\n  findHostInstanceByFiber: Renderer.findHostInstance\n});\n\nfunction isOrthographicCamera(def) {\n  return def.isOrthographicCamera;\n}\n\nconst stateContext = createContext({});\n\nfunction useMeasure() {\n  const ref = useRef(null);\n\n  const _useState = useState({\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0\n  }),\n        bounds = _useState[0],\n        set = _useState[1];\n\n  const _useState2 = useState(() => new ResizeObserver(_ref => {\n    let entry = _ref[0];\n    return set(entry.contentRect);\n  })),\n        ro = _useState2[0];\n\n  useEffect(() => {\n    if (ref.current) ro.observe(ref.current);\n    return () => ro.disconnect();\n  }, [ref.current]);\n  return [ref, bounds];\n}\n\nfunction makeId(event) {\n  return event.object.uuid + '/' + event.index;\n}\n\nconst Canvas = memo(_ref2 => {\n  let children = _ref2.children,\n      gl = _ref2.gl,\n      camera = _ref2.camera,\n      orthographic = _ref2.orthographic,\n      raycaster = _ref2.raycaster,\n      style = _ref2.style,\n      pixelRatio = _ref2.pixelRatio,\n      _ref2$vr = _ref2.vr,\n      vr = _ref2$vr === void 0 ? false : _ref2$vr,\n      _ref2$shadowMap = _ref2.shadowMap,\n      shadowMap = _ref2$shadowMap === void 0 ? false : _ref2$shadowMap,\n      _ref2$invalidateFrame = _ref2.invalidateFrameloop,\n      invalidateFrameloop = _ref2$invalidateFrame === void 0 ? false : _ref2$invalidateFrame,\n      _ref2$updateDefaultCa = _ref2.updateDefaultCamera,\n      updateDefaultCamera = _ref2$updateDefaultCa === void 0 ? true : _ref2$updateDefaultCa,\n      onCreated = _ref2.onCreated,\n      onPointerMissed = _ref2.onPointerMissed,\n      rest = _objectWithoutPropertiesLoose(_ref2, [\"children\", \"gl\", \"camera\", \"orthographic\", \"raycaster\", \"style\", \"pixelRatio\", \"vr\", \"shadowMap\", \"invalidateFrameloop\", \"updateDefaultCamera\", \"onCreated\", \"onPointerMissed\"]); // Local, reactive state\n\n\n  const _useState3 = useState(false),\n        ready = _useState3[0],\n        setReady = _useState3[1];\n\n  const _useMeasure = useMeasure(),\n        bind = _useMeasure[0],\n        size = _useMeasure[1];\n\n  const _useState4 = useState(() => new Vector2()),\n        mouse = _useState4[0];\n\n  const _useState5 = useState(() => {\n    const element = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n    element.style.display = 'block';\n    return element;\n  }),\n        defaultCanvas = _useState5[0];\n\n  const _useState6 = useState(() => {\n    const ray = new Raycaster();\n    if (raycaster) applyProps(ray, raycaster, {});\n    return ray;\n  }),\n        defaultRaycaster = _useState6[0];\n\n  const _useState7 = useState(() => {\n    const scene = new Scene();\n    scene.__interaction = [];\n    scene.__objects = [];\n    return scene;\n  }),\n        defaultScene = _useState7[0];\n\n  const _useState8 = useState(() => {\n    const cam = orthographic ? new OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new PerspectiveCamera(75, 0, 0.1, 1000);\n    cam.position.z = 5;\n    if (camera) applyProps(cam, camera, {});\n    return cam;\n  }),\n        defaultCam = _useState8[0],\n        _setDefaultCamera = _useState8[1];\n\n  const _useState9 = useState(() => {\n    const renderer = new WebGLRenderer(_extends({\n      canvas: defaultCanvas,\n      antialias: true,\n      alpha: true\n    }, gl));\n    renderer.setClearAlpha(0);\n\n    if (shadowMap) {\n      if (typeof shadowMap === 'object') {\n        renderer.shadowMap.enabled = true;\n        Object.assign(renderer, shadowMap);\n      } else {\n        renderer.shadowMap.enabled = true;\n        renderer.shadowMap.type = PCFSoftShadowMap;\n      }\n    }\n\n    return renderer;\n  }),\n        defaultRenderer = _useState9[0]; // Public state\n\n\n  const state = useRef({\n    ready: false,\n    manual: false,\n    vr: false,\n    active: true,\n    invalidateFrameloop: false,\n    frames: 0,\n    aspect: 0,\n    subscribers: [],\n    camera: defaultCam,\n    scene: defaultScene,\n    raycaster: defaultRaycaster,\n    mouse: mouse,\n    gl: defaultRenderer,\n    canvas: defaultCanvas,\n    captured: undefined,\n    canvasRect: {\n      bottom: 0,\n      height: 0,\n      width: 0,\n      left: 0,\n      right: 0,\n      top: 0,\n      x: 0,\n      y: 0\n    },\n    size: {\n      left: 0,\n      top: 0,\n      width: 0,\n      height: 0\n    },\n    viewport: {\n      width: 0,\n      height: 0,\n      factor: 0\n    },\n    initialClick: [0, 0],\n    initialHits: [],\n    subscribe: fn => {\n      state.current.subscribers.push(fn);\n      return () => state.current.subscribers = state.current.subscribers.filter(s => s !== fn);\n    },\n    setManual: takeOverRenderloop => {\n      state.current.manual = takeOverRenderloop;\n\n      if (takeOverRenderloop) {\n        // In manual mode items shouldn't really be part of the internal scene which has adverse effects\n        // on the camera being unable to update without explicit calls to updateMatrixWorl()\n        state.current.scene.children.forEach(child => state.current.scene.remove(child));\n      }\n    },\n    setDefaultCamera: camera => _setDefaultCamera(camera),\n    invalidate: () => invalidate(state),\n    intersect: event => handlePointerMove(event || {})\n  }); // This is used as a clone of the current state, to be distributed through context and useThree\n\n  const sharedState = useRef(state.current); // Writes locals into public state for distribution among subscribers, context, etc\n\n  useLayoutEffect(() => {\n    state.current.ready = ready;\n    state.current.size = size;\n    state.current.camera = defaultCam;\n    state.current.invalidateFrameloop = invalidateFrameloop;\n    state.current.vr = vr;\n  }, [invalidateFrameloop, vr, ready, size, defaultCam]); // Manage canvas element in the dom\n\n  useLayoutEffect(() => {\n    // Add canvas to the view\n    if (bind.current) bind.current.appendChild(defaultCanvas); // Start render-loop, either via RAF or setAnimationLoop for VR\n\n    if (!state.current.vr) invalidate(state);else {\n      defaultRenderer.vr.enabled = true;\n      defaultRenderer.setAnimationLoop(t => renderGl(state, t, 0, true));\n    } // Dispose renderer on unmount\n\n    return () => {\n      if (defaultRenderer) {\n        defaultRenderer.forceContextLoss();\n        defaultRenderer.dispose();\n      }\n\n      state.current.gl = undefined;\n      state.current.active = false;\n      unmountComponentAtNode(state.current.scene);\n    };\n  }, []); // Update pixel ratio\n\n  useLayoutEffect(() => {\n    if (pixelRatio) defaultRenderer.setPixelRatio(pixelRatio);\n  }, [pixelRatio]); // Adjusts default camera\n\n  useLayoutEffect(() => {\n    state.current.aspect = size.width / size.height || 0;\n\n    if (isOrthographicCamera(state.current.camera)) {\n      state.current.viewport = {\n        width: size.width,\n        height: size.height,\n        factor: 1\n      };\n    } else {\n      const target = new Vector3(0, 0, 0);\n      const distance = state.current.camera.position.distanceTo(target);\n      const fov = Math$1.degToRad(state.current.camera.fov); // convert vertical fov to radians\n\n      const height = 2 * Math.tan(fov / 2) * distance; // visible height\n\n      const width = height * state.current.aspect;\n      state.current.viewport = {\n        width,\n        height,\n        factor: size.width / width\n      };\n    } // Get canvas dom bounds\n\n\n    if (bind.current) state.current.canvasRect = bind.current.getBoundingClientRect();\n\n    if (ready) {\n      defaultRenderer.setSize(size.width, size.height);\n      /* https://github.com/drcmda/react-three-fiber/issues/92\n         Sometimes automatic default camera adjustment isn't wanted behaviour */\n\n      if (updateDefaultCamera) {\n        if (isOrthographicCamera(state.current.camera)) {\n          state.current.camera.left = size.width / -2;\n          state.current.camera.right = size.width / 2;\n          state.current.camera.top = size.height / 2;\n          state.current.camera.bottom = size.height / -2;\n        } else {\n          state.current.camera.aspect = state.current.aspect; // TODO: Why radius??\n          // state.current.camera.radius = (size.width + size.height) / 4\n        }\n\n        state.current.camera.updateProjectionMatrix();\n      }\n\n      invalidate(state);\n    } // Only trigger the context provider when necessary\n\n\n    sharedState.current = _extends({}, state.current);\n  }, [ready, size, defaultCam, updateDefaultCamera]); // This component is a bridge into the three render context, when it gets rendererd\n  // we know we are ready to compile shaders, call subscribers, etc\n\n  const IsReady = useCallback(() => {\n    const activate = useCallback(() => void (setReady(true), invalidate(state)), []);\n    useEffect(() => {\n      if (onCreated) {\n        const result = onCreated(state.current);\n        if (result && result.then) return void result.then(activate);\n      }\n\n      activate();\n    }, []);\n    return null;\n  }, []); // Render v-dom into scene\n\n  useLayoutEffect(() => {\n    if (size.width > 0 && size.height > 0) {\n      render(createElement(stateContext.Provider, {\n        value: sharedState.current\n      }, createElement(IsReady, null), typeof children === 'function' ? children(state.current) : children), state.current.scene, state);\n    }\n  });\n  /** Sets up defaultRaycaster */\n\n  const prepareRay = useCallback(event => {\n    if (event.clientX !== void 0) {\n      const canvasRect = state.current.canvasRect;\n      const left = canvasRect && canvasRect.left || 0;\n      const right = canvasRect && canvasRect.right || 0;\n      const top = canvasRect && canvasRect.top || 0;\n      const bottom = canvasRect && canvasRect.bottom || 0;\n      const x = (event.clientX - left) / (right - left) * 2 - 1;\n      const y = -((event.clientY - top) / (bottom - top)) * 2 + 1;\n      mouse.set(x, y);\n      defaultRaycaster.setFromCamera(mouse, state.current.camera);\n    }\n  }, []);\n  /** Intersects interaction objects using the event input */\n\n  const intersect = useCallback(function (event, prepare) {\n    if (prepare === void 0) {\n      prepare = true;\n    }\n\n    if (prepare) prepareRay(event);\n    const seen = new Set();\n    const hits = []; // Intersect known handler objects and filter against duplicates\n\n    const intersects = defaultRaycaster.intersectObjects(state.current.scene.__interaction, true).filter(item => {\n      const id = makeId(item);\n      if (seen.has(id)) return false;\n      seen.add(id);\n      return true;\n    });\n\n    for (let intersect of intersects) {\n      let receivingObject = intersect.object;\n      let object = intersect.object; // Bubble event up\n\n      while (object) {\n        if (object.__handlers) hits.push(_extends({}, intersect, {\n          object,\n          receivingObject\n        }));\n        object = object.parent;\n      }\n    }\n\n    return hits;\n  }, []);\n  /**  Handles intersections by forwarding them to handlers */\n\n  const handleIntersects = useCallback((event, fn) => {\n    prepareRay(event); // If the interaction is captured, take the last known hit instead of raycasting again\n\n    const hits = state.current.captured && event.type !== 'click' && event.type !== 'wheel' ? state.current.captured : intersect(event, false);\n\n    if (hits.length) {\n      const unprojectedPoint = new Vector3(mouse.x, mouse.y, 0).unproject(state.current.camera);\n\n      for (let hit of hits) {\n        let stopped = {\n          current: false\n        };\n        fn(_extends({}, event, hit, {\n          stopped,\n          unprojectedPoint,\n          ray: defaultRaycaster.ray,\n          // Hijack stopPropagation, which just sets a flag\n          stopPropagation: () => stopped.current = true,\n          sourceEvent: event\n        }));\n        if (stopped.current === true) break;\n      }\n    }\n\n    return hits;\n  }, []);\n  const handlePointer = useCallback(name => event => {\n    if (!state.current.ready) return; // Collect hits\n\n    const hits = handleIntersects(event, data => {\n      const object = data.object;\n      const handlers = object.__handlers;\n\n      if (handlers && handlers[name]) {\n        // Forward all events back to their respective handlers with the exception of click,\n        // which must must the initial target\n        if (name !== 'click' || state.current.initialHits.includes(object)) handlers[name](data);\n      }\n    }); // If a click yields no results, pass it back to the user as a miss\n\n    if (name === 'pointerDown') {\n      state.current.initialClick = [event.clientX, event.clientY];\n      state.current.initialHits = hits.map(hit => hit.object);\n    }\n\n    if (name === 'click' && !hits.length && onPointerMissed) {\n      let dx = event.clientX - state.current.initialClick[0];\n      let dy = event.clientY - state.current.initialClick[1];\n      let distance = Math.round(Math.sqrt(dx * dx + dy * dy));\n      if (distance <= 2) onPointerMissed();\n    }\n  }, [onPointerMissed]);\n  const hovered = new Map();\n  const handlePointerMove = useCallback(event => {\n    if (!state.current.ready) return;\n    const hits = handleIntersects(event, data => {\n      const object = data.object;\n      const handlers = object.__handlers; // Check presence of handlers\n\n      if (!handlers) return; // Call mouse move\n\n      if (handlers.pointerMove) handlers.pointerMove(data); // Check if mouse enter or out is present\n\n      if (handlers.pointerOver || handlers.pointerOut) {\n        const id = makeId(data);\n        const hoveredItem = hovered.get(id);\n\n        if (!hoveredItem) {\n          // If the object wasn't previously hovered, book it and call its handler\n          hovered.set(id, data);\n          if (handlers.pointerOver) handlers.pointerOver(_extends({}, data, {\n            type: 'pointerover'\n          }));\n        } else if (hoveredItem.stopped.current) {\n          // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n          data.stopPropagation(); // In fact, wwe can safely remove them from the cache\n\n          Array.from(hovered.values()).forEach(data => {\n            const checkId = makeId(data);\n\n            if (checkId !== id) {\n              if (data.object.__handlers.pointerOut) data.object.__handlers.pointerOut(_extends({}, data, {\n                type: 'pointerout'\n              }));\n              hovered.delete(checkId);\n            }\n          });\n        }\n      }\n    }); // Take care of unhover\n\n    handlePointerCancel(event, hits);\n    return hits;\n  }, []);\n  const handlePointerCancel = useCallback((event, hits) => {\n    if (!hits) hits = handleIntersects(event, () => null);\n    Array.from(hovered.values()).forEach(data => {\n      if (hits && (!hits.length || !hits.find(i => i.object === data.object))) {\n        const object = data.object;\n        const handlers = object.__handlers;\n        if (handlers && handlers.pointerOut) handlers.pointerOut(_extends({}, data, {\n          type: 'pointerout'\n        }));\n        hovered.delete(makeId(data));\n      }\n    });\n  }, []); // Render the canvas into the dom\n\n  return createElement(\"div\", _extends({\n    ref: bind,\n    onClick: handlePointer('click'),\n    onWheel: handlePointer('wheel'),\n    onPointerDown: handlePointer('pointerDown'),\n    onPointerUp: handlePointer('pointerUp'),\n    onPointerLeave: event => handlePointerCancel(event, []),\n    onPointerMove: handlePointerMove // On capture intersect and remember the last known position\n    ,\n    onGotPointerCapture: event => state.current.captured = intersect(event, false) // On lost capture remove the captured hit\n    ,\n    onLostPointerCapture: event => (state.current.captured = undefined, handlePointerCancel(event))\n  }, rest, {\n    style: _extends({\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden'\n    }, style)\n  }));\n});\n\nfunction useRender(fn, takeOverRenderloop, deps) {\n  if (takeOverRenderloop === void 0) {\n    takeOverRenderloop = false;\n  }\n\n  if (deps === void 0) {\n    deps = [];\n  }\n\n  const _useContext = useContext(stateContext),\n        subscribe = _useContext.subscribe,\n        setManual = _useContext.setManual; // This calls into the host to inform it whether the render-loop is manual or not\n\n\n  useMemo(() => takeOverRenderloop && setManual(true), [takeOverRenderloop]);\n  useEffect(() => {\n    // Subscribe to the render-loop\n    const unsubscribe = subscribe(fn);\n    return () => {\n      // Call subscription off on unmount\n      unsubscribe();\n      if (takeOverRenderloop) setManual(false);\n    };\n  }, deps);\n}\n\nfunction useThree() {\n  const _useContext2 = useContext(stateContext),\n        subscribe = _useContext2.subscribe,\n        props = _objectWithoutPropertiesLoose(_useContext2, [\"subscribe\"]);\n\n  return props;\n}\n\nfunction useUpdate(callback, dependents, optionalRef) {\n  const _useContext3 = useContext(stateContext),\n        invalidate = _useContext3.invalidate;\n\n  const localRef = useRef();\n  const ref = optionalRef ? optionalRef : localRef;\n  useEffect(() => {\n    if (ref.current) {\n      callback(ref.current);\n      invalidate();\n    }\n  }, dependents);\n  return ref;\n}\n\nfunction useResource(optionalRef) {\n  const _useState = useState(),\n        resource = _useState[0],\n        set = _useState[1];\n\n  const localRef = useRef(undefined);\n  const ref = optionalRef ? optionalRef : localRef;\n  useEffect(() => void set(ref.current), [ref.current]);\n  return [ref, resource];\n}\n/** experimental */\n\n\nfunction useLoader(proto, url, extensions) {\n  const key = useMemo(() => ({}), [url]);\n\n  const _useState2 = useState(() => new WeakMap()),\n        cache = _useState2[0];\n\n  const loader = useMemo(() => {\n    const temp = new proto();\n    if (extensions) extensions(temp);\n    return temp;\n  }, [proto]);\n\n  const _useState3 = useState(false),\n        _ = _useState3[0],\n        forceUpdate = _useState3[1];\n\n  useEffect(() => {\n    if (!cache.has(key)) {\n      loader.load(url, gltf => {\n        const temp = [];\n        gltf.scene.traverse(obj => obj.isMesh && temp.push({\n          geometry: obj.geometry,\n          material: obj.material\n        }));\n        cache.set(key, temp);\n        forceUpdate(i => !i);\n      });\n    }\n  }, [proto, key]);\n  return cache.get(key) || [];\n}\n\nconst apply = objects => {\n  console.warn('react-three-fiber: Please use extend ✅ instead of apply ❌, the former will be made obsolete soon!');\n  extend(objects);\n};\n\nexport { Canvas, addEffect, apply, applyProps, createPortal, extend, invalidate, isOrthographicCamera, render, stateContext, unmountComponentAtNode, useLoader, useRender, useResource, useThree, useUpdate };","map":null,"metadata":{},"sourceType":"module"}