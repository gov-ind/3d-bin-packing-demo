{"ast":null,"code":"/**\n * @author mrdoob / http://mrdoob.com/\n */\nimport { Color } from '../../math/Color.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\n\nfunction UniformsCache() {\n  var lights = {};\n  return {\n    get: function (light) {\n      if (lights[light.id] !== undefined) {\n        return lights[light.id];\n      }\n\n      var uniforms;\n\n      switch (light.type) {\n        case 'DirectionalLight':\n          uniforms = {\n            direction: new Vector3(),\n            color: new Color(),\n            shadow: false,\n            shadowBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n\n        case 'SpotLight':\n          uniforms = {\n            position: new Vector3(),\n            direction: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            coneCos: 0,\n            penumbraCos: 0,\n            decay: 0,\n            shadow: false,\n            shadowBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n\n        case 'PointLight':\n          uniforms = {\n            position: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            decay: 0,\n            shadow: false,\n            shadowBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2(),\n            shadowCameraNear: 1,\n            shadowCameraFar: 1000\n          };\n          break;\n\n        case 'HemisphereLight':\n          uniforms = {\n            direction: new Vector3(),\n            skyColor: new Color(),\n            groundColor: new Color()\n          };\n          break;\n\n        case 'RectAreaLight':\n          uniforms = {\n            color: new Color(),\n            position: new Vector3(),\n            halfWidth: new Vector3(),\n            halfHeight: new Vector3() // TODO (abelnation): set RectAreaLight shadow uniforms\n\n          };\n          break;\n      }\n\n      lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\n\nvar nextVersion = 0;\n\nfunction shadowCastingLightsFirst(lightA, lightB) {\n  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);\n}\n\nfunction WebGLLights() {\n  var cache = new UniformsCache();\n  var state = {\n    version: 0,\n    hash: {\n      directionalLength: -1,\n      pointLength: -1,\n      spotLength: -1,\n      rectAreaLength: -1,\n      hemiLength: -1,\n      numDirectionalShadows: -1,\n      numPointShadows: -1,\n      numSpotShadows: -1\n    },\n    ambient: [0, 0, 0],\n    probe: [],\n    directional: [],\n    directionalShadowMap: [],\n    directionalShadowMatrix: [],\n    spot: [],\n    spotShadowMap: [],\n    spotShadowMatrix: [],\n    rectArea: [],\n    point: [],\n    pointShadowMap: [],\n    pointShadowMatrix: [],\n    hemi: [],\n    numDirectionalShadows: -1,\n    numPointShadows: -1,\n    numSpotShadows: -1\n  };\n\n  for (var i = 0; i < 9; i++) state.probe.push(new Vector3());\n\n  var vector3 = new Vector3();\n  var matrix4 = new Matrix4();\n  var matrix42 = new Matrix4();\n\n  function setup(lights, shadows, camera) {\n    var r = 0,\n        g = 0,\n        b = 0;\n\n    for (var i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);\n\n    var directionalLength = 0;\n    var pointLength = 0;\n    var spotLength = 0;\n    var rectAreaLength = 0;\n    var hemiLength = 0;\n    var numDirectionalShadows = 0;\n    var numPointShadows = 0;\n    var numSpotShadows = 0;\n    var viewMatrix = camera.matrixWorldInverse;\n    lights.sort(shadowCastingLightsFirst);\n\n    for (var i = 0, l = lights.length; i < l; i++) {\n      var light = lights[i];\n      var color = light.color;\n      var intensity = light.intensity;\n      var distance = light.distance;\n      var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;\n\n      if (light.isAmbientLight) {\n        r += color.r * intensity;\n        g += color.g * intensity;\n        b += color.b * intensity;\n      } else if (light.isLightProbe) {\n        for (var j = 0; j < 9; j++) {\n          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\n        }\n      } else if (light.isDirectionalLight) {\n        var uniforms = cache.get(light);\n        uniforms.color.copy(light.color).multiplyScalar(light.intensity);\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n        uniforms.shadow = light.castShadow;\n\n        if (light.castShadow) {\n          var shadow = light.shadow;\n          uniforms.shadowBias = shadow.bias;\n          uniforms.shadowRadius = shadow.radius;\n          uniforms.shadowMapSize = shadow.mapSize;\n          state.directionalShadowMap[directionalLength] = shadowMap;\n          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;\n          numDirectionalShadows++;\n        }\n\n        state.directional[directionalLength] = uniforms;\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        var uniforms = cache.get(light);\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n        uniforms.color.copy(color).multiplyScalar(intensity);\n        uniforms.distance = distance;\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n        uniforms.coneCos = Math.cos(light.angle);\n        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));\n        uniforms.decay = light.decay;\n        uniforms.shadow = light.castShadow;\n\n        if (light.castShadow) {\n          var shadow = light.shadow;\n          uniforms.shadowBias = shadow.bias;\n          uniforms.shadowRadius = shadow.radius;\n          uniforms.shadowMapSize = shadow.mapSize;\n          state.spotShadowMap[spotLength] = shadowMap;\n          state.spotShadowMatrix[spotLength] = light.shadow.matrix;\n          numSpotShadows++;\n        }\n\n        state.spot[spotLength] = uniforms;\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        var uniforms = cache.get(light); // (a) intensity is the total visible light emitted\n        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n        // (b) intensity is the brightness of the light\n\n        uniforms.color.copy(color).multiplyScalar(intensity);\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors\n\n        matrix42.identity();\n        matrix4.copy(light.matrixWorld);\n        matrix4.premultiply(viewMatrix);\n        matrix42.extractRotation(matrix4);\n        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n        uniforms.halfWidth.applyMatrix4(matrix42);\n        uniforms.halfHeight.applyMatrix4(matrix42); // TODO (abelnation): RectAreaLight distance?\n        // uniforms.distance = distance;\n\n        state.rectArea[rectAreaLength] = uniforms;\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        var uniforms = cache.get(light);\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n        uniforms.color.copy(light.color).multiplyScalar(light.intensity);\n        uniforms.distance = light.distance;\n        uniforms.decay = light.decay;\n        uniforms.shadow = light.castShadow;\n\n        if (light.castShadow) {\n          var shadow = light.shadow;\n          uniforms.shadowBias = shadow.bias;\n          uniforms.shadowRadius = shadow.radius;\n          uniforms.shadowMapSize = shadow.mapSize;\n          uniforms.shadowCameraNear = shadow.camera.near;\n          uniforms.shadowCameraFar = shadow.camera.far;\n          state.pointShadowMap[pointLength] = shadowMap;\n          state.pointShadowMatrix[pointLength] = light.shadow.matrix;\n          numPointShadows++;\n        }\n\n        state.point[pointLength] = uniforms;\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        var uniforms = cache.get(light);\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        uniforms.direction.transformDirection(viewMatrix);\n        uniforms.direction.normalize();\n        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);\n        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);\n        state.hemi[hemiLength] = uniforms;\n        hemiLength++;\n      }\n    }\n\n    state.ambient[0] = r;\n    state.ambient[1] = g;\n    state.ambient[2] = b;\n    var hash = state.hash;\n\n    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {\n      state.directional.length = directionalLength;\n      state.spot.length = spotLength;\n      state.rectArea.length = rectAreaLength;\n      state.point.length = pointLength;\n      state.hemi.length = hemiLength;\n      state.directionalShadowMap.length = numDirectionalShadows;\n      state.pointShadowMap.length = numPointShadows;\n      state.spotShadowMap.length = numSpotShadows;\n      state.directionalShadowMatrix.length = numDirectionalShadows;\n      state.pointShadowMatrix.length = numPointShadows;\n      state.spotShadowMatrix.length = numSpotShadows;\n      hash.directionalLength = directionalLength;\n      hash.pointLength = pointLength;\n      hash.spotLength = spotLength;\n      hash.rectAreaLength = rectAreaLength;\n      hash.hemiLength = hemiLength;\n      hash.numDirectionalShadows = numDirectionalShadows;\n      hash.numPointShadows = numPointShadows;\n      hash.numSpotShadows = numSpotShadows;\n      state.version = nextVersion++;\n    }\n  }\n\n  return {\n    setup: setup,\n    state: state\n  };\n}\n\nexport { WebGLLights };","map":null,"metadata":{},"sourceType":"module"}