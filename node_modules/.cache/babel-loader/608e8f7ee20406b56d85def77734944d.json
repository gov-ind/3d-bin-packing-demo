{"ast":null,"code":"/**\n * @author alteredq / http://alteredqualia.com/\n * @author Mugen87 / https://github.com/Mugen87\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\nimport { Camera } from '../cameras/Camera.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { LineSegments } from '../objects/LineSegments.js';\nimport { Color } from '../math/Color.js';\nimport { FaceColors } from '../constants.js';\nimport { LineBasicMaterial } from '../materials/LineBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n\nvar _vector = new Vector3();\n\nvar _camera = new Camera();\n\nfunction CameraHelper(camera) {\n  var geometry = new BufferGeometry();\n  var material = new LineBasicMaterial({\n    color: 0xffffff,\n    vertexColors: FaceColors\n  });\n  var vertices = [];\n  var colors = [];\n  var pointMap = {}; // colors\n\n  var colorFrustum = new Color(0xffaa00);\n  var colorCone = new Color(0xff0000);\n  var colorUp = new Color(0x00aaff);\n  var colorTarget = new Color(0xffffff);\n  var colorCross = new Color(0x333333); // near\n\n  addLine('n1', 'n2', colorFrustum);\n  addLine('n2', 'n4', colorFrustum);\n  addLine('n4', 'n3', colorFrustum);\n  addLine('n3', 'n1', colorFrustum); // far\n\n  addLine('f1', 'f2', colorFrustum);\n  addLine('f2', 'f4', colorFrustum);\n  addLine('f4', 'f3', colorFrustum);\n  addLine('f3', 'f1', colorFrustum); // sides\n\n  addLine('n1', 'f1', colorFrustum);\n  addLine('n2', 'f2', colorFrustum);\n  addLine('n3', 'f3', colorFrustum);\n  addLine('n4', 'f4', colorFrustum); // cone\n\n  addLine('p', 'n1', colorCone);\n  addLine('p', 'n2', colorCone);\n  addLine('p', 'n3', colorCone);\n  addLine('p', 'n4', colorCone); // up\n\n  addLine('u1', 'u2', colorUp);\n  addLine('u2', 'u3', colorUp);\n  addLine('u3', 'u1', colorUp); // target\n\n  addLine('c', 't', colorTarget);\n  addLine('p', 'c', colorCross); // cross\n\n  addLine('cn1', 'cn2', colorCross);\n  addLine('cn3', 'cn4', colorCross);\n  addLine('cf1', 'cf2', colorCross);\n  addLine('cf3', 'cf4', colorCross);\n\n  function addLine(a, b, color) {\n    addPoint(a, color);\n    addPoint(b, color);\n  }\n\n  function addPoint(id, color) {\n    vertices.push(0, 0, 0);\n    colors.push(color.r, color.g, color.b);\n\n    if (pointMap[id] === undefined) {\n      pointMap[id] = [];\n    }\n\n    pointMap[id].push(vertices.length / 3 - 1);\n  }\n\n  geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));\n  geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));\n  LineSegments.call(this, geometry, material);\n  this.camera = camera;\n  if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();\n  this.matrix = camera.matrixWorld;\n  this.matrixAutoUpdate = false;\n  this.pointMap = pointMap;\n  this.update();\n}\n\nCameraHelper.prototype = Object.create(LineSegments.prototype);\nCameraHelper.prototype.constructor = CameraHelper;\n\nCameraHelper.prototype.update = function () {\n  var geometry = this.geometry;\n  var pointMap = this.pointMap;\n  var w = 1,\n      h = 1; // we need just camera projection matrix inverse\n  // world matrix must be identity\n\n  _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target\n\n\n  setPoint('c', pointMap, geometry, _camera, 0, 0, -1);\n  setPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near\n\n  setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);\n  setPoint('n2', pointMap, geometry, _camera, w, -h, -1);\n  setPoint('n3', pointMap, geometry, _camera, -w, h, -1);\n  setPoint('n4', pointMap, geometry, _camera, w, h, -1); // far\n\n  setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);\n  setPoint('f2', pointMap, geometry, _camera, w, -h, 1);\n  setPoint('f3', pointMap, geometry, _camera, -w, h, 1);\n  setPoint('f4', pointMap, geometry, _camera, w, h, 1); // up\n\n  setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);\n  setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);\n  setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross\n\n  setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);\n  setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);\n  setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);\n  setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);\n  setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);\n  setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);\n  setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);\n  setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);\n  geometry.getAttribute('position').needsUpdate = true;\n};\n\nfunction setPoint(point, pointMap, geometry, camera, x, y, z) {\n  _vector.set(x, y, z).unproject(camera);\n\n  var points = pointMap[point];\n\n  if (points !== undefined) {\n    var position = geometry.getAttribute('position');\n\n    for (var i = 0, l = points.length; i < l; i++) {\n      position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);\n    }\n  }\n}\n\nexport { CameraHelper };","map":null,"metadata":{},"sourceType":"module"}